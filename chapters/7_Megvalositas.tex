A felhasználó által begépelt bemeneti szöveg több átalakításon esik át míg futtatható állapotba nem kerül. Ez a fejezet a fejlesztés folyamatát, a feldolgozás egyes lépéseinek bemutatását tartalmazza.

\subsection{Formázás}

Első lépésben a felhasználó szöveget gépel be a program által nyújtott szövegdobozba, majd rákattint a fordítás gombra. Mielőtt a program értelmezése elkezdődne, lefut rajta egy formázó algoritmus, mely a szöveget soraira tördeli, majd ezeket a \ref{sec:formatting} alfejezetben leírt szabályok szerint formázza.

Ehhez a következő változókat tartja számon:

\begin{itemize}
    \item \texttt{prevIndent} - értéke igaz, ha az előző sorban volt behúzás,
    \item \texttt{prevDedent} - értéke igaz, ha az előző sor egy szinttel kevébsé lett behúzva,
    \item \texttt{oldIndent} - az előző sor behúzásának értéke számszerint.
\end{itemize}

Megnézzük, hogy a jelenlegi sor első szava megegyezik-e egy olyan kulcsszóval, mely új blokkot kezdeményez ("ha", "függvény", "eljárás", "ciklus") és azt, hogy az utolsó szava pedig "vége"-e.

Ha az előbbi feltétel igaz, de az utóbbi nem, a behúzás egy szinttel növekszik. Ha az utóbbi feltétel igaz, akkor az első feltétel állapotától függetlenül mindig csökkentjük a behúzás szintjét. Erre azért van szükségünk, mivel a blokkokat lezáró utasítások magukban tartalmazzák a nyitó utasítást is (például a "függvény vége" tartalmazza a "függvény" szót is), így enélkül a precedencia nélkül egyszerre próbálnánk növelni és csökkenteni is a behúzást, mely így nem változna.

Ez alól egyetlen kivétel a "különben" kulcsszó, melyet egyszerre kell egy szinttel kevésbé behúznunk, ám a következő sorban már ismét egy szinttel jobban. Ennek ellenőrzésére a formázó figyelembe veszi, hogy a jelenlegi sor tartalmazza-e a "különben" kulcsszót.

Ezután az előző sor információit tartalmazó változók és a jelenlegi sor információi alapján eldöntjük, hogy szükséges-e új sort tennünk a következő utasítás elé.

Végül befüzzük a jelenlegi sort a végeredménybe a megfelelő behúzással és az esetleges új sorral együtt.

\subsection{Tokenizálás}
\label{sec:tokenizer}

Ahogy azt a \ref{sec:tokenizer_tech} alfejezetben bevezettem a jól formázott szövegünk feldolgozásának első lépése annak tokenekre bontása.

Bár alapesetben a tokenizáló algoritmus feladata, hogy a kommenteket és helykihagyásokat (üres helyek és sortörések) kiszűrje, a saját implementációmban ezek is tokenként kerülnek elmentésre, majd a következő lépés előtt kerülnek szűrésre.

Az általam készített tokenizálás egy egyszerű, a szöveget balról-jobbra feldolgozó algoritmussal van megvalósítva. A feldolgozásért felelős osztály rendelkezik a nyelv összes lehetséges tokenjére egy metódussal, mely sikeres feldolgozás esetén a hozzá tartozó tokennel tér vissza (a fentebb specifikált egyéb információkat beleértve) és a bemenetetet annyi karakterrel lépteti előrébb, ahány a tokenhez szükséges. Sikertelen feldolgozás esetén null értékkel térünk vissza és az esetleges előreléptetést visszavonjuk.

Az algoritmus sorrendben végigpróbálja az összes lehetséges token mintáját és, ha olyat talál amely ráillik a jelenlegi bemenetre, akkor továbblépteti a bemeneti szöveget és a kapott tokent hozzáfűzi a kimeneti tokenek listájához.

Mivel ennek a folyamatnak az algoritmusa a modern számítógépeken a felhasználó számára érzékelhetetlenül kevés időt vesz igénybe (egy napjainkban átlagos számítógépen ez körülbelül 20-25 millisecundum), így a felhasználótól kapott bemenet még gépelés közben át is esik a folyamaton. 

Fölmerülhet bennünk, hogy erre mi szükség van, hisz a tokenizálás folyamatát elég lenne csupán egyszer a fordítás folyamatának elején lefuttatnunk. A válasz, hogy a program egyben szintaktikai kiemelést is végez a tokenek segítségével (tehát a különböző nyelvi elemeket különféle színekkel jelöljük, így egyszerűbbé téve a programozó számára, hogy eligazodjon a kódon). Ez egy egyszerű szótár adatszerkezettel van implementálva, minden token típushoz hozzápárosítunk egy színt, melyet a felhasználói felületen beállítunk a megfelelő szövegrészletekhez.

Az egyetlen hibakezelés, melyet ezen lépés során tudunk végezni az az értelmetlen vagy nem megfelelő tokenek szűrése. Mivel a tokenizáló algoritmusnak nincs tudása arról, hogy a különböző tokeneknek milyen sorrendben is kell követniük egymást (ez a következő lépés feladata), ezért hiba nélkül fel fog dolgozni olyan kódokat is, mely hibás szintaxissal rendelkezik.

Tehát például egy olyan kód, mely a következőképp szól „ha amíg x+5” hiba nélkül tokenizálható, hisz az összes benne található nyelvi elem érvényes tokennek felel meg annak ellenére, hogy a kód maga nyilvánvalóan hibás.

Viszont hiba lehet például egy le nem zárt szöveg, vagy olyan karakter vagy karakterkombináció ami semelyik kulcsszónak nem része (például ";" vagy "\verb|--|").

Ha a tokenizálás hibás tokenbe ütközik, a folyamat rögtön megáll és a hibás tokentől kezdve vörös kiemeléssel tudatjuk vizuálisan, hogy a feldolgozás sikertelen.

\subsection{Szintaxisfa generálás}
\label{sec:parser}

A szintaxisfa generelásához a kódomban egy úgynevezett monadikus kombinátor parsert használtam, melynek működési elvét egy Haskell nyelven írt programot bemutató cikkből\cite{monadic} vettem át.

A parser a következőképp működik: Olyan függvényeket specifikálunk, mely bemenetként megkapja a bemeneti szöveget és azt az indexet, ahol jelenleg tartunk a szövegben és mely egy felhasználó által specifikált értékkel és egy új (bemenet, index) párossal tér vissza, melyben az index annyival előrébb lett tolva, ahány elemet felhasználtunk. Az algoritmus használható lenne sima szövegeken is (az eredeti papír így is tesz), viszont a saját fordítómban a parser a tokenizálásból eredő listát használja fel bemenetként.

A fentebb említett függvényeket "kombinátoroknak" nevezzük. A név onnan ered, hogy az egyes függvények egymással összeköthetőek (tehát \textit{kombinálhatóak}), így egyre bonyolultabb parsereket tudunk felépíteni. Ennek módja az úgynevezett \textit{bind} ("kötés") függvény, mely két kombinátort vár bemenetként és egy új kombinátorral tér vissza. Ez lefuttatja először az első függvényt, ha ez hiba, akkor visszatér ezzel a hibával. Ha nem, akkor az ebből kapott \texttt{(bemenet, index)} párost és az így kapott feldolgozott értéket átadja a második függvénynek. 

Fontos megjegyezni, hogy egy érvényes tokenekből álló lista nem feltétlen eredményez érvényes szintaxisfát. Hiába képes a tokenizáló értelmezni a "ha ha ha ha" vagy "ciklus elágazás" bemenetet, ezek értelemszerűen nem alkotnak szintaktikailag érvényes kódot. Ha egy kombinátor bárhol nem képes egy illő mintát se találni, a folyamat hibával tér vissza és megszakad.

\subsubsection{Alapvető kombinátorok}

A cikk, mely alapján dolgoztam a következő alapvető függvényeket definiálja, melyek segítségével a nyelvi elemeket értelmezni tudó parsereket építjük fel:

\begin{itemize}
    \item \textbf{return} - bemenettől függetlenül mindig egy megadott értékkel tér vissza,
    \item \textbf{fail} - bemenettől függetlenül mindig egy megadott hibával tér vissza,
    \item \textbf{item} - a bemenet első értékével tér vissza, ha az üres, akkor pedig hibával,
    \item \textbf{sat} - ha a bemenet első értékére igaz egy predikátum, akkor ezzel az értékkel tér vissza, különben hibával,
    \item \textbf{many} - egy másik kombinátort futtat le a bemeneten annyiszor, ameddig az érvényes értékkel tér vissza, majd visszatér ezen értékek listájával,
    \item \textbf{many1} - a \textit{many} kombinátor feladatát látja el, de minimum egy értékkel kell visszatérnie, különben hibával tér vissza,
    \item \textbf{or} - megpróbál egy kombinátort, ha az hibával tér vissza, visszatér egy második értékével,
    \item \textbf{sepBy} - két kombinátort vár bemenetként, melyeket egymás után futtat le, oly módon, hogy a második értékét mindig elveti, az elsőből pedig a \textit{many} kombinátorhoz hasonlóan listát készít. Például egy felsorolás esetén, az első kombinátor a lista elemei, a második pedig az ezeket elválasztó vesszők és üres helyeket fogadó kombinátor,
    \item \textbf{sepBy1} - a \textit{sepBy} kombinátor feladatát látja el, de minimum egy értékkel kell visszatérnie, különben hibával tér vissza,
    \item \textbf{chain} - két kombinátort vár bemenetként, mellyel műveleteket tudunk parsolni \texttt{elem operátor elem} alakban. Például, ha \texttt{elem} számokat fogadó és az \linebreak\texttt{operátor} pedig az összeadás jelét fogadó kombinátor, akkor egy olyan kombinátort kapunk eredményként, mely képes összeadásokat értelmezni.
    
    Ez a kombinátor balrekurzív, így nem csak egyszerű műveleteket, hanem \texttt{elem operátor (elem operátor (...))} alakban is képes értelmezni, tetszőleges mélységig.
    \item \textbf{left} - lefuttat egymás után két kombinátort, majd elveti a második értékét,
    \item \textbf{right} - lefuttat egymás után két kombinátort, majd elveti az első értékét.
\end{itemize}

\subsubsection{Kiegészítő kombinátorok}

Ezeket kiegészítettem még pár saját vagy más forrásból származó kombinátorral, melyek olyan mintákat rövidítenek le, amelyek a kódban nagyon gyakran fordultak elő:

\begin{itemize}
    \item \textbf{map} - végrehajt egy kombinátort, majd az ebből kapott értéket átadja egy nem-kombinátor függvénynek. A kódban ezt az egyes parserek utolsó lépésének használtam, ennek segítségével változtattam a különféle kapott értékeket szintaxisfa elemmé,
    \item \textbf{maybe} - végrehajt egy kombinátort, mely ha értékkel tér vissza továbbengedi. Ha hibával tér vissza, a hibát elveti és helyette null értékkel, de sikeresen tér vissza,
    \item \textbf{choice} - tetszőleges számú kombinátort vár bemenetként, majd ezeket az \textit{or} kombinátor segítségével egyesével végigpróbálja, míg érvényes értéket nem kap, mellyel visszatér. Ha nincs érvényes érték, az utolsó hibával tér vissza,
    \item \textbf{parens} / \textbf{brackets} - a bemenetet \verb_(kombinátor)_ vagy \verb_[kombinátor]_ alakban dolgozza fel, eldobva a zárójeleket. Listáknál hasznos, hisz a listák nyitó és záróelemei nem szükségesek.
    \item \textbf{matchT} - ellenőrzi hogy a bemenet következő elemének típusa megegyezik-e a felhasználó által megadott tokentípussal,
    \item \textbf{mapChoice} - paraméterként egy szótár típusú adatszerkezetet vár, melyből a bemenet következő eleme alapján választja ki, melyik kombinátor fusson le következőleg.
    
    Hozzárendelésnél hasznos, hisz a például \texttt{változó <- érték} és a \texttt{változó <- Függvényhívás()} első két tagja minden esetben megegyezik, így ha idáig eljutottunk, biztosak lehetünk benne, hogy csak ez a két lehetőség következhet (a valódi értelmezőben ennél több ág is lehetséges, itt a példa kedvéért egyszerűsítettem).
\end{itemize}

\subsubsection{A \textit{do}-alak használata kombinátorok lineáris egybefűzésére}

Végezetül mivel néhány parser igen hosszúra tud nyúlni, így ez elkerülhetetlenül ahhoz vezet, hogy több egymásba ágyazott \textit{bind} hívást kéne kezelnünk. Az ilyen kódon a rengeteg zárójel-pár és különféle helyeken bevezetett paraméterek és változók miatt hírhedten nehéz kiigazodni. Olyannira hogy a JavaScriptben fejlesztő programozók frusztrációjukban a "callback hell" vagyis "visszahívó (függvény) pokol" fantázianévvel illeték a jelenséget.

Ezt elkerülvén a parserek mellé még egy osztályt implementáltam, mely a Haskell nyelv úgynevezett \textit{"do"} ("csináld") szintaxisát imitálja. Ennek lényege, hogy a monadikus függvények egymásba való beágyazott meghívását lineáris kóddá tudjuk alakítani úgy, hogy ugyanazt a végeredményt produkálja.

Ehhez egy listában tároljuk az egymás után meghívott parsereket és hogy ezeket milyen névhez szeretnénk kötni, majd egy végső függvényhívással a program egy rekurzív ciklus segítségével "visszajátssza" számunkra a \textit{bind} hívásokat úgy mintha azt mi magunk tettük volna manuálisan.

Ennek hasznosságát egy példával demonstrálnám. Tegyük fel, hogy van három parserünk, \texttt{parserA}, \texttt{parserB} és \texttt{parserC}, melyeket sorban szeretnénk lefuttatni, majd egy három paramétert fogadó \texttt{fn} függvénynek szeretnénk átadni.

Manuális \textit{bind} függvény hívással ez a következőképp néz ki:

\begin{code}{Egymásba ágyazott \textit{bind} hívások}{src_nested_bind}
parserA.bind(A => 
    parserB.bind(B => 
        parserC.map(C => 
            fn(A,B,C))))
\end{code}

Annak ellenére, hogy rövid és egyszerű példát választottam, a \ref{src_nested_bind}-as forráskód által bemutatott esetben már most háromszoros beágyazással kell dolgoznunk. A valós Pszeudokód egyes elemeinek értelmezéséhez öt-hat különféle parserre és esetleg több ignorált elemre is (mely külön feldolgozást nem igényel, csupán a nyelvi elem típusának eldöntéséhez kell\footnote{Például ilyen elem az \texttt{amíg} kulcsszó, mely önmagában jelentéssel nem rendelkezik, azonban szükséges a predikátum- (\ref{whileciklus} fejezet) és számláló-alapú (\ref{forciklus} fejezet) ciklusok megkülönböztetésére.}) is szükség van, melyhez így legalább hatszoros beágyazást kéne alkalmaznunk, mely nyilvánvalóan teljesen átláthatatlan és szerkeszthetetlen.

A következő példában "Do" alakba írva láthatjuk ugyanezt. Az itt látható \texttt{Parser} osztály a parserek ősosztálya, melyen a \texttt{do()} egy statikus metódus, mely a inicializál egy \texttt{Do} osztályú elemet, amire parsereket köthetünk:

\begin{code}{Lineáris alakba bontott parserek}{src_linear_bind}
Parser.do()
    .bind("A", parserA)
    .bind("B", parserB)
    .bind("C", parserC)
    .result(({A,B,C}) => fn(A,B,C))
\end{code}

Ahogy az a \ref{src_linear_bind} forráskódban látható, a kód sokkal átláthatóbb és könnyebben kezelhető, hisz, ha például egy új parsert kell hozzáadnunk, módosítanunk, vagy kivennünk, elég csupán egy sort átírnunk, nem kell zárójelek után vadásznunk vagy észben tartanunk hány szint mélyen is jár a beágyazás. 

Ez a módszer önmagában sokkal kezelhetőbbé teszi a kódot, azonban még kiegészítettem pár extra kulcsszóval, mely még inkább megkönnyítheti az egyes parserek megírását. Névszerint ezek:

\begin{itemize}
    \item \textbf{bindT} - a \textit{matchT} parser segítségével egy tokent köt a névhez,
    \item \textbf{ignore} - ha a parser sikeres, figyelmen kívül hagyja az eredményét, ha hibával tér vissza, akkor megszakítja az értelmezést,
    \item \textbf{ignoreT} - az \textit{ignore} és a \textit{matchT} összeépítése,
    \item \textbf{maybeT} - működése megegyezik a \textit{bindT}-vel, viszont ha nem találunk megfelelő tokent, null értékkel tér vissza.
\end{itemize}

Ezen eszközök segítségével a 2.1-es fejezetben látható szintaxis szinte egy az egyben átültethető, (a rekurzív függvényhívásokból eredő) elhanyagolhatóan lassabb futásidő mellett. Különbségeik ellenére itt is a  tokenizáláshoz hasonló alapötlet alapján dolgozunk: Sorra próbáljuk az egyes mintákat és, ha megfelelőt találunk szintaxisfa-elemet alkotunk, melyet beleillesztünk a készülő fába.

\subsection{Típusellenőrzés}
\label{sec:typecheck}

A típusellenőrzés feladata, hogy megbizonyosodjon afelől, hogy egy szintaktikailag helyes szintaxisfa szemantikailag is érvényes kódból készült. Ennek részleteiről a \ref{sec:typecheck_tech} alfejezetben írok.

A saját megvalósításomban a típusellenőrzéshez egy rekurzív függvényt használok fel, mely két bemenettel rendelkezik. Az első egy szintaxisfa-elem (kezdetben értelemszerűen a program gyökéreleme), a második pedig egy úgy nevezett típus-szótár, melyet rögtön definiálunk. A függvény kimenete sikeres típusellenőrzés esetén az adott szintaxisfa-elem típusa és egy opcionálisan módosított típus-szótár. Működése, hogy minden lehetséges szintaxisfa-elem típusra megadunk szabályokat, melyek segítségével ki tudjuk számolni annak típusát és, hogy gyermekelemei szintén megfelelőek-e.

Például, ha az összeadás műveletét ellenőrizzük, akkor meg kell néznünk, hogy a bal és jobb oldali elem szám típusú értékek-e (melyeket a függvény rekurzív meghívásával érünk el) és, ha azok, akkor a művelet eredménye is szám lesz (mely tényt esetleg egy másik típusellenörzésnél is felhasználhatunk). Ha valamely szabály meghiúsul, akkor kivételt dobunk, mely által az egész folyamat megszakad.

A típus-szótár olyan adatszerkezet, mely nevekhez köt olyan típusokat, melyekre késöbb még szükségünk lehet. Eltárolja tehát a változókat és a függvények paramétereit és visszatérési típusait. Mivel nem globális változó, hanem paraméterként van átadva a típusellenörzési függvénynek, ezért külön kód nélkül támogatja, hogy azok a változók melyek felszabadulásra kerülnek a függvény visszatértével szintén elérhetetlenné válnak. Erre a következő, \ref{src_typemap} forráskód szolgál példaképp.

\begin{code}{Példa a típus-szótár működésére}{src_typemap}
// Típus-szótár itt üres
ha Predikátum() akkor
    // Típus-szótár: {x = SZÁM}
    x <- 5
függvény vége
// Típus-szótár újra üres, hisz a fentebbi 
// változótartomány végéhez értünk.
kiír x
// Hiba! 'x' értéke nincs definiálva
\end{code}

A típusellenörzés szabályai röviden a következőek:

\begin{itemize}
    \item atom esetén annak értéke alapján meg tudjuk határozni a típust,
    \item értékadáshoz esetén eltároljuk a változót és annak típusát a jelenlegi típus-szótárba, megbizonyosdva afelől, hogy az eltárolt típus nem üres-típus,
    \item változó esetén lekérjük annak típusát név alapján. Ha nem találjuk kivételt dobunk,
    \item függvénydeklaráció esetén eltároljuk annak visszatérési értékét a függvénytörzs utasításai alapján és a paramétereinek számát és azok elvárt típusait. Ha egy paraméter generikus, annak kezelését lejjebb, a \ref{sec:generic} fejezetben mutatom be.
    \item függvényhívás esetén lekérjük a fentebb eltárolt értékeket és a következőket ellenőrizzük:
    \begin{itemize}
        \item a függvény megfelelő számú paramétert kapott-e,
        \item a függvény által kapott paraméterek típusai egyeznek-e a definícióban szereplő paraméterek típusaival,
        \item esetleges generikus típusok esetén az ezekre való behelyettesítés után értelmes függvénytörzset kapunk-e, mely visszatérési értéke megegyezik a szignatúrában definiált vagy annak híján az előre kiszámolt visszatérési értékkel.
    \end{itemize}
    Ha a hívás minden feltételnek megfelel, a függvény visszatérési értékének típusával térünk vissza,
    \item aritmetikai, logikai, és összehasonlító műveletek esetén ellenőrizzük a tagokat és a végeredmény típusával térünk vissza,
    \item elágazás esetén ellenőrizzük, hogy a predikátum logikai érték és hogy az ágak ugyanolyan típusú értékkel térnek vissza (mely lehet üres is),
    \item ciklusok esetén a ciklusváltozó értékét eltároljuk a típus-szótárba, majd a ciklus törzsének típusával térünk vissza,
    \item egyéb utasítások esetén a visszatérési típus üres. 
\end{itemize}

\subsubsection{Generikus függvények kezelése}
\label{sec:generic}

Egy esetben azonban a típus nem dönthető el rögtön, ez az eset pedig a generikus függvények definiálása. Ilyenkor a \texttt{T} (vagy bármely más egy, nagybetűs karakter) ideiglenes értékkel hivatkozunk egy olyan típusra, melyet csak a függvény meghívásakor vagyunk képesek kiszámolni. Ekkor segít nekünk ismét a típus-szótár, mely a sima névhez kötésen túl képes típusokat behelyettesíteni is.

Ha meghívunk egy generikus paraméterrel rendelkező függvényt egzakt típussal, akkor a típusellenörző ismét lefut a függvény törzsén. Ekkor azonban, a szótár behelyettesíti ezt az egzakt típust az összes olyan generikus típushoz kötött névhez, ahol a típus ideiglenes egy-karakteres értéke megegyezik a behelyettesített típus értékével.

Ez alapján, ha például \texttt{T}-re helyettesítünk \texttt{egész} típussal, akkor a \texttt{T, T tömb,} és \texttt{T referencia} típusok mind megfelelő egzakt típussá változnak (\texttt{egész}, \texttt{egész} \texttt{tömb}, és \texttt{egész} \texttt{referencia}).

\subsection{Szekvenciális program generálása}
\label{sec:compiler}

Az így kapott szintaxisfa ekkor garantáltan helyes szinaktika, típusok, és szemantika szempontjából. Ekkor lehetőségünk volna önmagában lefuttatni egy interpreter segítségével, ám két okból mégse ezt tesszük.

Először is, bár a program futtatható, de mivel a szintaxisfákat feldolgozó algoritmusok definíció szerint rekurzívak, így a folyamatot nem lehet megállítani futás közben threading használata nélkül. Ám mivel JavaScriptes környezetben fut a kódunk, így ez nem elérhető szánunkra és mivel a projekt egyik előírása, hogy a kódnak megállíthatónak és léptethetőnek kell lennie, így szükséges még egy extra feldolgozási lépés.

Másodszor pedig az ilyen átalakítás betekintést nyújthat egy kezdő programozó számára, hogy hogy nagy vonalakban hogy is működik egy számítógép, hiszen a szekvenciális kódba fejtett program egy leegyszerűsített Assembly-szerű nyelv gépi kódjává válik, melyet a végső lépésben egy apró virtuális gép képes lefuttatni.

Ebben a lépésben egy előre meghatározott sorrend szerint bejárjuk a szintaxisfát és az elemek alapján olyan utasításokat fűzünk egy listába, melyeket a gép egymástól függetlenül képes elvégezni.

\subsubsection{Példa a generálás demonstrálásához}

Az alábbiakban vegyük egy egyszerű ciklus átalakítását példaképp. Kiinduló kódunk a \ref{src_counter} forráskód, mely elszámol egytől ötig, kiírva az egyes számokat a kimenetre.

\begin{code}{Egy egyszerű ciklus, mely elszámol ötig}{src_counter}
i <- 1 (1)

ciklus amíg i < 5 (2)
  kiír i (3)
  i <- i + 1 (4)
ciklus vége (5)
\end{code}

A fentebbi Pszeudokód a következő szekvenciális kódra fordul:

\begin{code}{Az előbbi kód szekvenciális kódra fordítva}{src_counter_vm}
ESCOPE false

 PUSH   1 (1)
 SETVAR i

 LABEL  while_0_pred (2)
 GETVAR i
 PUSH   5
 BINOP  <
 FJMP   while_0_end
 LABEL  while_0_body

 ESCOPE false
  GETVAR i (3)
  PRINT

  GETVAR i (4)
  PUSH   1
  BINOP  +
  SETVAR i
 LSCOPE

 JMP   while_0_pred (5)
 LABEL while_0_end

LSCOPE
\end{code}

A virtuális gép által végrehajtható utasítások részletes listája és leírása a \ref{sec:vminsts} alfejezetben olvasható, itt csupán nagy vonalakban közlöm az utasítások kis csoportjai milyen hatást váltanak ki.

A \ref{src_counter_vm} forráskódban látható szekvenciális kód megőrzi az eredeti utasítások sorrendjét, mégpedig:

\begin{enumerate}
    \item Az \texttt{i} változó értéket kap,
    \item A ciklus predikátuma során ellenőrizzük, hogy be kell-e lépnünk egyátalán a ciklusba és ha nem, akkor ugrunk a ciklus utánra,
    \item Ha viszont igen, akkor először kiírjuk az \texttt{i} változó értékét,
    \item Majd megnöveljük azt eggyel,
    \item Végül a ciklus végére érünk, ahonnan a predikátumellenőrzés ismét lezajlik.
\end{enumerate}

\subsection{Végrehajtás}

A létrehozott szekvenciális kód egy egyszerű verem-alapú virtuális gépen kerül lefuttatásra. A virtuális gép a következő elemekből épül fel:

\subsubsection{Programkód}

A szekvenciális kód egy (csak olvasható) tömbként kerül átadásra. A tömb egyes elemei két fő részből épülnek fel:

Minden elem kötelezően tartalmazza mely utasítást is szeretnénk végrehajtani. Az érvényes kódok listája a \ref{sec:vminsts} alfejezetben olvasható. Bármely más érték vagy hibás argumentummal meghívott utasítás esetén a gép kivételt dob és a futtatás megszakad.

Az utasításkód mellett az utasítástól függően eltárolhatunk még nullától három darab konstans, fordítási időben ismert egy vagy több atomi értéket tartalmazó extra adattagot, amelyeket az utasítás veremműveletek nélkül képes elérni. Feladatuk olyan extra információk kódolása, amely vagy fordítás közben elveszik a program kódjából (például, hogy a jelenlegi utasítás függvényen belül lett-e hívva, vagy azon kívül) vagy (mivel már fordítás közben ismerjük ezeket az értékeket) fölöslegesen tennék zajosabbá a vermet.

\subsubsection{Utasítás-számláló} 

Egy kód által csak indirekt módon változtatható regiszter, mellyel számontartjuk a jelenleg végrehajtott utasítás indexét, tehát a jelenlegi utasítás mindig \texttt{tape[PC]}. Értéke 1-el nő minden végrehajtási lépés után, beleértve az ugrásokat is, hisz a \texttt{LABEL} utasítás amit így átugrunk amúgy se végez egyéb feladatot.

\subsubsection{Számláló-verem} 

Verem típusú adatszerkezet. Függvéynhívások esetén ide mentjük, azokból való visszatérés esetén pedig innen töltjük be a legutóbbi utasítás-számláló értékét.

\subsubsection{Verem} 

Egy veremként használt dinamikus méretű tömb, mely atomi értékeket és mutatókat képes tárolni. Minden művelet innen veszi le azokat az értékekeket, melyekkel dolgozik és ide helyezi végeredményét.

\subsubsection{Memória}

A program memóriáját egy dinamikusan növekvő tömbbel szimuláljuk, mely feladata atomi értékek és ezekből felépülő tömbök eltárolása. Az egyes memóriacellákat azok sorszáma alapján azonosítjuk. A memória számontartja mely cellák címei vannak változóhoz kötve, ezáltal a már nem használt adatok kiszűrhetőek és celláik felszabadíthatóak új értékek számára,

\subsubsection{Változók} 

Egy változótartományokra (ezek működését részletesebben a \ref{code_scope} fejezetben tárgyalom) bontott asszociatív tömb. Elemei szöveges neveket párosítanak mutatókkal (melyek a változóhoz tartozó memóriacella címének számszerű értéke).

\subsubsection{Futás-indikátor} 

Egy logikai változó, mely hamis érték esetén azt jelzi hogy a következő lépés végrehajtása előtt meg kell állítanunk a virtuális gépet. Ezzel jelezzük a futtatási környezet számára, hogy a program futása véget ért vagy pedig hibakeresési törésponthoz értünk.

\subsection{A virtuális gép által értelmezett utasítások listája}
\label{sec:vminsts}

Alább olvasható a szekvenciális kódba fejtés után kapott, a virtuális gép által értelmezett összes utasítás.

\newcommand{\codetable}[3]{
\minipage[t]{\linewidth}\vspace{-8pt}
    \begin{center}
        \captionof{table}{#1\label{#2}}
        \begin{tabularx}{\textwidth}{ l l X }
            \hline
            \multicolumn{1}{c}{\bfseries{Utasítás}} &
            \multicolumn{1}{c}{\bfseries{Paraméter}} &
            \multicolumn{1}{c}{\bfseries{Leírás}} \\
            \hline
            #3
            \hline
        \end{tabularx}
    \end{center}
\endminipage
}

\subsubsection{Hibakeresés}

\codetable{Hibakeresési utasítások}{code_debug}{
    PRINT & - & Kiveszi a verem legfelső elemét és kiírja a kimenetre. \\
    DEBUG & - & Megállítja a virtuális gép futását hibakeresési célból. \\
}

Bár \ref{code_debug} táblában látható két kulcsszó nem része a nyelv specifikációjának, a program hasznossága érdekében fontosnak tartottam, hogy elérhetőek legyenek. A \texttt{PRINT} kulcsszó lehetővé teszi, hogy a lefuttatott algoritmusok a végfelhasználó számára is látható kimenettel rendelkezzenek, míg a \texttt{DEBUG} sokkal kényelmesebbé teszi annak folyamatát, hogy a hibakeresés során a programot a megfelelő utasítás előtt állítsuk meg. 

\subsubsection{Ugrások}

A \ref{code_jump} tábla mutatja be a nyelv által támogatott két elágazási formát. A szokásos Assembly nyelvekhez hasonlóan itt is lehetőségünk van feltételes és feltétel nélküli ugrásokhoz, ám azoktól eltérően külön "ugrás ha [nagyobb, kisebb, (nem) egyenlő]" utasítások helyett, a feltételes ugrás a verem tetején lévő logikai érték alapján dönti el, hogy a program számláló változzon-e vagy sem.

\codetable{Ugrásokra vonatkozó utasítások}{code_jump}{
    LABEL & név & Létrehoz egy \textit{név} nevű cimkét, melyre az ugrások hivatkozhatnak. \\
    JMP & cimke & Feltétel nélkül ugrik a \textit{cimke} nevű cimkéhez. \\
    FJMP &cimke & Ugrik a \textit{cimke} nevű cimkéhez, ha a verem tetején lévő elem hamis. \\
}

Fontos még megjegyezni, hogy a nyelv csak abszolút címekre való ugrást engedélyez, mivel relatív ugrásra (tehát a jelenlegi vagy felhasználó által megadott címtől bizonyos meghatározott távolságra lévő címre lépni) nincs szükségünk és csak nehezebbé tenné az egymást követő utasítások menetét.

\subsubsection{Függvényhívás és függvényekből való visszatérés}

Mivel a Pszeudokód lehetőséget biztosít függvények és eljárások létrehozására, így ezt a virtuális gépben is biztosítanunk kell, ezeket a \ref{code_func} tábla mutatja be.

\codetable{Függvényhívás és visszatérési utasítások}{code_func}{
    CALL & függvény & Meghívja a \textit{függvény} függvényt. A jelenlegi program számláló (PC) elmentésre kerül a számláló-verembe, majd ugrunk a \textit{függvény} cimkéhez. \\
    RETURN & - & Az \texttt{LSCOPE} művelethez hasonlóan megszünteti a jelenlegi változótartományt, majd leveszi a számláló-verem legfelső elemét és betölti a PC regiszterbe. \\
    RETCMP & hossz & \textit{hossz} hosszúságú tömböt készít a veremben lévő elemekből, majd egy erre mutató címet helyez el a tömbön. \\
}

Maguk a függvények a kód többi részével együtt kerülnek listába, a fordító nem helyezi őket külön memóriaterületre. Azonban, hogy elkerüljük, hogy a futás során az értelmező belépjen egy meg nem hívott függvény törzsébe, a függvények elé egy feltétel nélküli ugrást helyezünk, mellyel annak végére ugrunk és onnan folytatjuk a végrehajtást.

A \texttt{CALL} utasítás lebontható volna egy egyszerű feltétel nélküli ugrásra és a program számláló jelenlegi értékének a számláló-veremre helyezéséért felelős utasításokra, ám mivel a számláló-veremben tárolt értékek csak függvényhívás és azokból való visszatérés esetén módosulnak, így egybe vettem a kettőt.

\subsubsection{Veremműveletek}

\codetable{Veremműveletek utasításai}{code_stack}{
    NOT  & - & A verem tetején lévő logikai értéket megfordítja. \\
    PUSH & érték & A verem tetejére helyezi az \textit{érték} értéket. \\
    VOID & - & Elveti a verem tetején lévő elemet. \\
}

A \ref{code_stack} táblából a \texttt{VOID} kulcsszó az egyetlen, mely némi magyarázatot kíván. Mivel a függvényhívások nem rendelkeznek információval arról, hogy kifejezésként vagy utasításként futnak-e, így a visszatérési értékük minden esetben a verembe kerül, még akkor is ha a program ezzel az értékkel a továbbiakban nem kíván foglalkozni.

Ez jobb esetben csupán nehezebbé teheti a folyamat átláthatóságát (hisz értelmetlen értékek maradnak a veremben), rosszabban viszont hozzájárulhat a programozó önhibáján kívüli hibás működéshez, ha a veremben ottmaradt fölösleges érték egy másik utasítás által kerül felhasználásra.

Épp emiatt a fordító a kifejezésként meghívott függvények esetén egy extra \texttt{VOID} utasítást is a kódba iktat, mely egyszerűen megszabadul ettől az értéktől majd továbblép.

\subsubsection{Műveletek}

A következő három táblában rendre a \texttt{BINOP} kulcsszót alkalmazzuk, mely működését a megadott paraméter (operátor) határozza meg. Az utasítás leveszi a verem első két elemét (\textit{első} és \textit{második}), majd ezeken elvégzi a műveletet és az eredményt a veremre helyezi vissza.

Fontos megjegyezni, hogy bár a verem miatt \textit{első} és \textit{második} fordított sorrendben kerülnek levételre a veremről, a virtuális gép mégis helyes sorrendben adja át őket a műveleteknek.

\codetable{Aritmetikai műveletek}{code_arithm}{
    BINOP & + & Összeadja \textit{első}-t és \textit{második}-t. \\
    BINOP & - & Kivonja \textit{első}-t és \textit{második}-t. \\
    BINOP & * & Összeszorozza \textit{első}-t és \textit{második}-t. \\
    BINOP & / & Elosztja \textit{első}-t \textit{második}-al és a kapott értéket lefelé kerekíti. \\
    BINOP & mod & Az \textit{első} és \textit{második} érték hányadosának maradékát adja. \\
}

A \ref{code_arithm} tábla utasításainak végeredményei mind szám típusú értékek.

\codetable{Összehasonlító műveletek}{code_comp}{
    BINOP & < & Igaz, ha \textit{első} kisebb, mint \textit{második}. \\
    BINOP & > & Igaz, ha \textit{első} nagyobb, mint \textit{második}. \\
    BINOP & <= & Igaz, ha \textit{első} kisebb vagy egyenlő, mint \textit{második}. \\
    BINOP & >= & Igaz, ha \textit{első} nagyobb vagy egyenlő, mint \textit{második}. \\
    BINOP & = & Igaz, ha \textit{első} egyenlő \textit{második}-al. \\
    BINOP & =/= & Igaz, ha \textit{első} nem egyenlő \textit{második}-al. \\
}

A \ref{code_comp} tábla utasításainak végeredményei mind logikai értékek.

\codetable{Összehasonlító műveletek}{code_logic}{
    BINOP & és & Igaz, ha \textit{első} és \textit{második} értéke is igaz. \\ 
    BINOP & vagy & Igaz, ha \textit{első} vagy \textit{második} értéke igaz. \\ 
}

A \ref{code_logic} tábla utasításainak végeredményei szintén mind logikai értékek.

\subsubsection{Változótartományok létrehozása és megszüntetése}
\label{sec:scope}

A változótartomány (angol nevén \textit{"scope"}) alatt egy olyan régiót értünk, ahol az azon belül létrehozott változóknak elérhetőknek kell lenniük és a tartomány végeztével pedig fel kell szabadulniuk. Ezen tartományok létrehozására és megszüntetésére a \ref{code_scope} táblázatban látható utasításokat használhatjuk. 

\codetable{Tartományműveletek}{code_scope}{
    ESCOPE & függvény & Új változótartományt generál. Ha \textit{függvény} értéke igaz, az új tartomány függvényhatárként jön létre.\\
    LSCOPE & - & Feltakarítja az utolsó változótartományt. \\
}

Az alapszabály, hogy az egymásba ágyazott tartományokon belülről kifelé mindig elérhetőek a változók, de kivülről befelé nem. Ha van egy függvénytörzsünk például, amiben létrehozunk egy változót, akkor ez a változó a függvénytörzsön belül nyitott egyéb változótartományokban is elérhető lesz, viszont az ezekben a tartományokban létrehozott változók a függvénytörzsben nem lesznek elérhetőek.

Ez alól az egyetlen kivétel a függvényeket elhatároló változótartományok, melyeknél a változók értékének keresése megáll.

\begin{code}{Példa a függvények tartományainak elhatárolására}{src_scope}
// (1) A tartomány üres

eljárás PéldaBelső(z : egész)
    // (5) A tartomány értéke {z = 2}
    kiír z
eljárás vége

függvény Példa()
    // (2) A tartomány üres

    x <- 1

    // (3) A tartomány értéke {x = 1}

    ha x < 5 akkor
        y <- x * 2
        // (4) A tartomány értéke {x = 1, y = 2}

        PéldaBelső(y)
    elágazás vége

    // (6) A tartomány ismét értéke {x = 1}
    vissza x
függvény vége

// (7) A tartomány itt üres
kiír Példa()
\end{code}

Ahogy az a \ref{src_scope} forráskódban látható, az 5. lépésnél, bár a \texttt{z} értéke valóban szintén kettőre lett állítva, ahogy az az \texttt{y} változóban is történt, se az \texttt{y}, se az \texttt{x} változó nem elérhető annak ellenére, hogy a \texttt{PéldaBelső} függvény tartománya a \texttt{Példa} függvény törzsén belül található.

Ennek a kivételnek célja, hogy a programozó számára egyértelmű legyen mely változók és értékek mely függvényhez is tartoznak. Ha tegyük fel egy programban a második sorban definiálnánk egy változót egy függvényben, melyet legközelebb a századik sorban, egy teljesen más függvényben módosítanánk, az bármely más programozó számára (de akár a program eredetí készítőjének is pár hónap elteltével) teljesen átláthatatlan kódot eredményezne.

Egyes programozási nyelvekben lehetőségünk van a változók úgynevezett árnyékolásra is (angolul \textit{"variable shadowing"}), mely annyit jelent, hogy ha egy változótartományon belül módosítjuk egy változó értékét, akkor a módosult érték csupán a tartományon belül érvényes, annak elhagyásakor visszaáll az eredetire.

\begin{code}{C nyelven írt példa a változók árnyékolására}{src_c_shadowing}
void shadowing() {
    int y = 3;
    int x = 5;
    printf("%d\n", x); // Kimenet: 5
    printf("%d\n", y); // Kimenet: 3

    {
        int x = 6;
        y = 8;
        printf("%d\n", x); // Kimenet: 6
        printf("%d\n", y); // Kimenet: 8
    }

    printf("%d\n", x); // Kimenet: 5
    printf("%d\n", y); // Kimenet: 8
}
\end{code}

Mivel a Pszeudokód nem rendelkezik külön szintaxissal változók deklarálására (mint például a C-ben a típus kiírása a változó elé, ahogy az a \ref{src_c_shadowing} forráskódban látható), így normális esetben nincs lehetőségünk változók árnéykolására. Ez alól az egyetlen kivétel a függvényparaméterek, melyek neve egyezhet a függvényt tartalmazó tartományban már létező változó nevével, mely esetben árnyékolás lép fel:

\begin{code}{Példa az egyező nevű változók függetlenségére Pszeudokódban}{src_pseudo_no_shadowing}
x <- 5
kiír x // 5

eljárás Teszt(x : egész)
    kiír x // 5

    x <- x * 2

    kiír x // 10
eljárás vége

Teszt(x)
kiír x // 5
\end{code}

Ahogy az a \ref{src_pseudo_no_shadowing} forráskódban látható, hiába található meg az \texttt{x} változó mind a külső, mind a belső változótartományban, az értékük egymástól független.

Ha mindenféleképp szeretnénk, hogy egy külső változó egy függvényen belül is elérhető legyen, oly módon, hogy a függvényben végzett változtatások kívülről is láthatóak legyenek, akkor a változót \texttt{címszerint} kell átadnunk. Erre a \ref{src_pseudo_shadowing} forráskódban láthatunk példát.

\begin{code}{Példa a változók árnyékolására Pszeudokódban}{src_pseudo_shadowing}
x <- 5
kiír x // 5

eljárás Teszt(címszerint x : egész)
    kiír x // 5

    x <- x * 2

    kiír x // 10
eljárás vége

Teszt(&x)
kiír x // 10
\end{code}

\subsubsection{Változók címének lekérése és értékeik beállítása}

\codetable{Címlekérő műveletek}{code_addr}{
    ADDRESS & változó & Lekéri a \textit{változó} címét és a veremre helyezi.  \\
    ARRADDR & tömb, dimenzióSzám & Levesz a veremről \textit{dimenzióSzám} elemet, majd ezeket indexképp felhasználva a veremre helyezi a \textit{tömb} megfelelő elemének címét. \\
}

A \ref{code_addr} táblában látható műveletekkel kérhetjük le az egyes változók és tömb elemek címeit mutatók formájában. A mutató egy egyszerű adatszerkezet, mely csupán egy címből és egy extra adattagból áll, aminek feladata, hogy jelezze, hogy nem egyszerű számmal, hanem egy címmel van dolgunk.

A mutatók ideiglenes elemek, melyek csak a veremben jelennek meg és minden esetben egy változóhoz kell kötnünk őket, mielőtt az általuk mutatott értékkel tudnnánk dolgozni. Mivel a Pszeudokód nem igényel mutató-aritmetikát (tehát kifejezetten memória-címeken való műveletvégzést, amely például a C nyelvben igencsak megszokott), így nincs szükségünk külön cím- és értéklehívó utasításokra.

\codetable{Korábbi utasítások a változók értékének lehívására}{code_getvar}{
    GETARR & változó & Lekéri a \textit{változó} értékét, majd ezt a veremre helyezi.  \\
    GETVAR & változó, dimenzióSzám & A verem tetején lévő \textit{dimenzióSzám} darab elem alapján lekéri a \textit{változó} tömb megfelelő indexén található elemét, majd ezt a veremre helyezi. \\
}

Az értelmező egy korábbi változatában két extra kulcsszóval is rendelkezett, melyek a \ref{code_getvar} táblában láthatók. Ezek feladata lényegében az volt, amit a virutális gép jelenlegi változata automatikusan elvégez, vagyis az egyes változók értékének lehívása azok címének alapján.

Mivel a programok ezen kulcsszavak többé-kevésbé ugyanazt tették mint a címlekérő műveletek és a programok nélkülük se váltak különösképp bonyolultabbá, így a végső értelmezőből kihagyásra kerültek.

\codetable{Változó-kreáló műveletek}{code_mkvar}{
    SETARR & tömb, dimenzióSzám & A verem legfelső \textit{dimenzióSzám} darab eleme alapján beállítja a \textit{tömb} megfelelő indexét a veremben található következő értékre. \\
    SETVAR & változó & Lekéri a verem tetején lévő elemet és elmenti \textit{változó}-ba. \\
    MKREF & változó & Lekéri a verem tetején lévő elemet, melynek mutatónak kell lennie (egyéb esetben hibát dobunk). A \textit{változó} nevű változó címét ezen mutató címére állítjuk be. \\
    ARRCMP & változó, dSzám, hossz & Leveszi a tömb legfelső \textit{dSzám} elemét, majd ezeket indexként értelmezve, leveszi a tömb legfelső \textit{hossz} elemét és ezeket sorra az előbb kiszámolt indexek alapján befűzi a \textit{változó} tömbbe. \\
}

Míg a \ref{code_getvar} tábla felelt a változók értékének lekéréséről, a \ref{code_mkvar} dolga, hogy egyáltalán értéket tudjunk adni ezeknek a változóknak. Mint azt feljebb tárgyaltuk, a változók maguk valójában nem többek, mint szöveges névvel rendelkező "álnevek" címek számára, így az egyes változók értékének beállítása valójában az általuk mutatott memória cella (vagy tömb esetében cellák) manipulálása.

A Pszeudokód támogat mind érték alapú, mind pedig referencia alapú átadást függvények esetében. Az előbbit a \texttt{SETVAR} és \texttt{SETARR} utasítások biztosítják, melyek a megadott memóriacímen lévő értéket lemásolják és a másolat memóriacímét kötik az új változóhoz. Az utóbbit pedig az \texttt{MKREF} utasítással valósítjuk meg, mely lehetővé teszi, hogy ugyanarra a címre több változóval is hivatkozzunk.

Az \texttt{ARRCMP} utasítás segítségével olyan kódokat tudunk lefordítani mint amely a \ref{code:arrcmp} mellékletben látható.

\begin{code}{Példa a tömb eleméhez tömbbel való hozzárendelésre}{code:arrcmp}
tömb <- TáblaLétrehoz(egész)[3,2]
tömb[1] <- (1,2)
kiír tömb // [1,2, 0,0, 0,0]
\end{code}

Feladata, hogy a jobboldalon található tömböt a baloldali tömbbe töltse a baloldalt található indextől kezdve.

\codetable{Tömb-kreáló műveletek}{code_mkarr}{
    MKARR & változó & Lekéri a verem tetején található \textit{érték}-et, majd készít egy \textit{érték} hosszú tömböt, melyet elment \textit{változó}-ba. \\
    COMPRE & változó & Lekéri a verem legfelső \textit{darab} elemét, majd lekéri a következő \textit{darab} mennyiségű elemet. Ezekből tömböt alkot, melyet elment \textit{változó}-ba. \\
}

Tömböt kétféleképp kreálhatunk vagy adott hossz és dimenziók alapján, vagy pedig előre megadott elemek alapján. A \ref{code_mkarr} táblában találhatóak ezekhez az utasítások.

\subsection{Felhasználói felület}

A felhasználói felület egy egyszerű HTML oldal, mely működését egy JavaScript osztály vezérlni. Ennek feladata a fordítóprogram meghívása, a kapott lineáris kódból virtuális gép kreálása, és végül ennek vezérlése és állapotának kijelzése a felhasználó számára. 

\addimage{screenshot_edited.png}{A felhasználói felület képernyőképe}{screenshot}

A \ref{fig:screenshot} ábrán látható a felhasználói felület, mely a következő elemeket tartalmazza magában:

\begin{enumerate}
    \item Algoritmusválasztó - A jegyzetben található algoritmusok jelennek meg itt, fejezetre bontva. Az egyes algoritmusok címére kattintva az betöltődik a szerkesztőbe,
    \item Szerkesztő - A felhasználó ide írhatja a kódot, mely még gépelés közben szintaxiskiemelésen esik át,
    \item Gombok - A szerkesztőt és a virtuális gépet vezérlik. Lehetőségünk van a kód formázására, fordítására, lefuttatására, és végül egy-egy utasítást előre és visszafelé lépnünk,
    \item Belső állapotot figyelő elemek - Feladatuk a virtuális gép egyes belső elemeinek követése.
    \item Kimenet - A \texttt{kiír} utasítás kifejezései ide kerülnek megjelenítésre. Hiba esetén szintén ide írjuk az üzenetet a felhasználó számára,
\end{enumerate}

A belső állapotot figyelő elemek színekkel jelzik, hogy épp mi történik az általuk figyelt értékekkel. Zöld színnel jelöljük, ha új elemet vezetünk be, sárgával, ha meglévő elem változik, és pirossal, ha egy elem törlésre került. A gyorsabb sebesség érdekében a felület csak akkor frissül, ha a virtuális gép meg van állítva, így nem pazarlunk ciklusokat olyan elemek megjelenítésére és módosítására, melyeket a felhasználó a futás sebessége miatt amúgy sem látna.
