A program teszteléséhez a következő módszereket alkalmaztam:

\subsection{A jegyzetben található algoritmusok lefordítása}

Mivel a program része, hogy az oldalsávból a felhasználó betölthet tetszőleges algoritmusokat a jegyzetből, így célszerűnek láttam, hogy ezekkel automatikus tesztelést is végezzek.

A tesztelési környezet sorra lefuttatja a tokenizálás, értelmezés, és típusellenőrzés lépéseit az egyes algoritmusokon, majd ennek eredményét egy webes felületen összegzi a felhasználó számára.

A program jelenlegi állapotában mind a kilencvenhat algoritmust sikeresen feldolgozza. Ezek listája elérhető a \ref{algs} mellékletben.

Ezen módszer előnye, hogy semmi felhasználói interakciót nem kíván és átfogóan ellenőrzi a program futásának első három állomását (a formázásás lépését nem ellenőrizzük, hisz lényegi átalakítást nem végez). Hátránya azonban, hogy a kód bár garantáltan helyes típusosság szempontjából, az implementáció pontosságát nem ellenőrzi, hisz az egyes függvények nem kerülnek lefuttatásra.

\subsection{Példa algoritmusok lefuttatása}

Az előző fejezetben felvázolt hiányosság pótlására néhány algoritmust manuálisan is lefuttatunk példa értékekre, ezzel tesztelve, hogy az implementáció helyesen értelmezi a kódunk.

\addimage{teszt.png}{Az algoritmusok tesztelésének folyamata}{testing}

A \ref{fig:testing} ábrán látható ennek folyamata. Adott algoritmus esetén megadjuk annak bemenetét és az elvárt kimenetet. A bemenetet Pszeudokód értékké konvertáljuk, majd létrehozunk egy virtuális gépet, melyben az így kapott értéket a \texttt{bemenet} változóban tesszük elérhetővé. Eztán lefordítjuk az ellenőrizni kívánt algoritmust és meghívjuk a szolgáltatott értékkel. A függvény kimenetét ezután visszakonvertáljuk JavaScript értékké, majd ezt összehasonlítjuk az elvárt értékkel.

\minipage[t]{\linewidth}\vspace{-14pt}
\begin{center}
    \captionof{table}{Tesztelt algoritmusok\label{tesztelt}}
    \begin{tabularx}{\textwidth}{ l l X X }
        \hline
        \multicolumn{1}{c}{\bfseries{Kód / Algoritmus neve}}  &
        \multicolumn{1}{c}{\bfseries{Bemenet}} &
        \multicolumn{1}{c}{\bfseries{Várt kimenet}} &
        \multicolumn{1}{c}{\bfseries{Kapott kimenet}}      \\

        \hline
        \texttt{kimenet <- bemenet * 2} & 5 & 10 & 10 \\
        \texttt{kimenet <- bemenet + 5} & "Helló!" & Típushiba & Típushiba \\
        1.1. Euklideszi algoritmus & [15, 33] & 3 & 3 \\
        3.4. Buborékrendezés & [3,2,1,5,4] & [1,2,3,4,5] & [3,2,1,5,4] \\
        3.4. Buborékrendezés átalakítva & [3,2,1,5,4] & [1,2,3,4,5] & [1,2,3,4,5] \\
        4.5. Az első N Fibonacci szám & 3 & [1,2,3] & [1,2,3] \\ 
        4.5. Az első N Fibonacci szám & 5 & [1,2,3,5,8,13] & [1,2,3,5,8,13] \\ 
        2.5. Rendezettség eldöntése & [3,2,1] & Hamis & Hamis \\
        2.5. Rendezettség eldöntése & [1,2,3,4,5] & Igaz & Igaz \\
        5.3. Logaritmikus keresés (10-re) & [3,5,8,10,12] & 4 & 4 \\
        \hline
    \end{tabularx}
\end{center}
\endminipage

Ahogy látható a Buborékrendezés algoritmus tesztelésénél hibás értéket kapunk. Ez amiatt történik, mivel a megvalósításomban a \texttt{for}-típusú számláló ciklusok nem képesek lefelé számolni, ami az algoritmushoz szükséges lenne. Ezt küszöböli ki az alatta lévő verzió, mely kódja a \ref{code:bubor} forráskódban található.

\begin{code}{Átalakított buborékrendezés}{code:bubor}
eljárás BuborékRendezés(címszerint x : T tömb, n : egész)
    i <- n

    ciklus amíg i >= 2
        ciklus j <- 1-től (i - 1)-ig
            ha x[j] > x[j + 1] akkor
                x[j] <-> x[j + 1]
            elágazás vége
        ciklus vége

        i <- i - 1
    ciklus vége
eljárás vége

kimenet <- bemenet
BuborékRendezés(&kimenet, 5)
\end{code}
