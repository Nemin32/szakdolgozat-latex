In summary of the work that had been done during the dissertation, I have first introduced Pseudocode as a programming language, naming its properties, syntax, and runtime semantics, with extra attention paid to features and elements done differently than how they appear in the lecture notes.

After this I have showcased what processes the user's inputs must undergo to be transformed into a format that the computer is capable of executing. I defined the techniques used for the individual steps and gave an informal summary of how they work.

After the list of techniques, I listed the languages I considered viable candidates to use in my project. I have considered the pros and cons of each and why I did not ultimately choose to pick them. Finally, I described TypeScript, the language I selected, in a similar fashion.

Having picked a language, I focused next on the system's plan, which constituted of the individual parts of my program and how these interact with each other, along with how the user interacts with the program itself and what path their input should take depending on whether the compilation was successful or not. I also provided a plan for the user interface and its required functionality.

Next came the implementation of the plan described earlier. I explained the algorithms and techniques specific to my dissertation which I first mentioned in chapter \ref{sec:similar}, including the process of tokenizing the user's input, creating an abstract syntax tree from the tokens using a parser, breaking said syntax tree into linear bytecode, the virtual machine that can execute said code, and finally a tabular list of all the instructions this machine can understand. Finally, I also showcased the user interface's design and its functionality.

The implementation then underwent testing using two methods. The first method is less specific, however, it is executed on all ninety-six algorithms found in the lecture notes. This method tests only the first four steps of the compilation, which checks whether the algorithm tested is consistent in terms of types. This ensures that the algorithm we're testing is both syntactically and semantically consistent. The second method tests the program from start to finish by taking a predetermined set of inputs and outputs and running the former on given algorithms before comparing their results with the provided outputs. If the two match, we know the algorithm has run correctly.

The final program is capable of interpreting the Pseudocode utilized at Ã“buda University, along with checking the typing and syntactical validity of algorithms. It is also able to run these programs in a way that allows the programmer to see into the inner workings of its environment. With these features implemented, I have accomplished the set goals of my dissertation. The code may be accessed at {\color{blue}{https://github.com/Nemin32/pseudokod}}.
