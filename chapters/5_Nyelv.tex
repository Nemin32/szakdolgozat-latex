Mivel a progrmamom weben át felszolgált formátumban szeretném elérhetővé tenni, így egyrészt elkerülhetetlen valamennyi JavaScript használata, hisz a böngészők natívan ezt az egy nyelvet támogatják. A fő program megírásához háromféle opciónk van:

\subsection{Kliens-szerver architektúra}

Lehetőségünk van a felhasználói felületet böngészőben futtatni, míg a kód feldolgozását és lefuttatását egy gépi kódra forduló nyelvben írt szerveren feldolgozni. Ennek előnye, hogy bármely nyelvet alkalmazhatjuk a szerver megírására, amely képes internetes kommunikációra, hátránya viszont, hogy majdnem minden mást cserébe lényegesen megbonyolít.

A kliens és felhasználó közötti összes kommunikáció így hálózati alapon történik, különböző adat-reprezentációkat használva. Bár ez volt az első megközelítésem, gyakorlatban hamar túl bonyolulttá vált a kód és úgy döntöttem ez a módszer nem nyújt elég pozitívumot a komplexitásért cserébe. 

\subsubsection{Java}

A szakdolgozat megvalósításának elején először a Java nyelvre esett a választásom, hisz egyrészt sokat használtam már, másrészt natívan támogatja a nagyszerű ANTLR4 könyvtárat, melyet kifejezetten programozási nyelvek értelmezésére és feldolgozására alkottak meg.\cite{antlr-book}

Sajnos azonban a fejlesztés során hamar rájöttem, hogy mivel a nyelv nem képes WASM formátumba fordulni, egy kliens-szerver architektúra megvalósítása pedig túlságosan eltért volna a szakdolgozat témájától, így végül elvetettem használatát.

Ennek ellenére a jelenlegi megvalósítás alapjait fektette le a nyelv használata, így mindenképp megérdemel egy helyet a listában. A nyelv értékelésének összefoglalója az \ref{javanyelv}-es táblázatban látható.

\begin{center}
  \captionof{table}{A Java nyelv értékelése.\label{javanyelv}}
  \begin{tabularx}{\textwidth}{X X}
    \hline
    \multicolumn{1}{c}{\bfseries{Pozitívumok}}         & \multicolumn{1}{c}{\bfseries{Negatívumok}} \\
    \hline
    Ismerős szintaxis & Webes kommunikáció csak API-kon át \\
    ANTLR4 könyvtár & Nem fordul webes formátumba \\
    Dinamikus memóriakezelés \\
    Erősen típusos nyelv \\
    \hline
  \end{tabularx}
\end{center}

\subsubsection{C\#}

A C\# a Microsoft válasza a Java nyelvre, mely a .NET keretrendszer része. Hasonlóképp az ihlető nyelvhez, szintén automatikus memóriakezeléssel rendelkezik, ezen kívül kiváló osztály és interfész támogatással bír. Ezek segítségével a kód sokkal egyszerűbben tehető átlátahóbbá és sok óvatlanságból eredő hiba válik vagy lehetetlenné vagy könnyen megelőzhetővé.

A nyelvhez beépülő ASP.NET és Blazor könyvtárak segítségével az amúgy kliensoldalon futó nyelv a böngészőbe is átültethető.

Bár az egyetemi tanulmányaim miatt sok tapasztalattal rendelkezem már a nyelvvel kapcsolatban, nem szívesen kötném magam egy webes frameworkhöz, így a C\# sem megfelelő számomra a feladathoz. A nyelv értékelésének összefoglalója az \ref{csnyelv}-as táblázatban látható.

\comptable{A C\# nyelv értékelése.}{csnyelv}{
  Sok személyes tapasztalat & Terjengősebb mint a többi nyelv \\
  A memóriakezelést a rendszer intézi, nekünk nem kell foglalkoznunk vele & Semennyi tapasztalatom nincs a webes frameworkökkel \\
  Blazor framework kifejezetten webes alkalmazások fejlesztésére & Futtatási környezetet igényel, nagyobb mint a fentebbi nyelvek \\
  Kiforrottan támogatja az objektum-orientált programozást \\
  Kiváló standard könyvtár \\
  Jó szövegkezelés \\
}

\subsubsection{LISP}

A LISP\cite{lisp} egy C-hez hasonló korú nyelv, mely lényege, hogy a kód és az adat ugyanabban a rekurzív adatszerkezetben vannak tárolva. Ez nem más, mint az úgynevezett \textit{s-kifejezés} (\textit{s-expression}), mely háromféle elemből állhat: 

\begin{itemize}
  \item lehet atomi érték, melyet önmagával reprezentálunk,
  \item lehet üres érték, melyet a \texttt{nil} értékkel jelölünk,
  \item végül pedig lehet úgynevezett \textit{cons}-cella\footnote{A \textit{cons} szó itt a \textit{"construct"} ("épít") angol kifejezésre, egyáltal a nyelvben használt egyik beépülő függvényre utal, mely segítségével értékeket tudunk összeláncolni és ezáltal az adatszerkezeteink felépíteni.\cite{cons}}, mely két adattagból áll. Ezek közül első a \textit{fej}, mely az adat maga, amit eltárolunk (mely lehet vagy atomi érték vagy egy másik s-kifejezés), a második pedig a \textit{farok}, amely egy mutató, mely egy másik s-kifejezésre mutat.
\end{itemize}

Ezeket felhasználva bármilyen bonyolultságú és hosszú adatot el tudunk tárolni \textit{cons}-cellákból álló láncolt listák alakjában. 

Bár egyáltalán nem tartom megfelelő nyelvnek a projektemhez, nem hagyhattam ki a megemlítését, hisz a Structure and Interpretation of Computer Programs\cite{sicp} című könyv sokat segített a folyamat megértésében, mely a LISP egyik átalakított változatát, a Scheme-t használja és egy fejezetében egy interpreter majd később egy fordító megírását mutatja be. A nyelv értékelésének összefoglalója az \ref{lispnyelv}-ös táblázatban látható.

\begin{center}
  \captionof{table}{A LISP nyelv értékelése.\label{lispnyelv}}
  \begin{tabularx}{\textwidth}{X X}
    \hline
    \multicolumn{1}{c}{\bfseries{Pozitívumok}}               & \multicolumn{1}{c}{\bfseries{Negatívumok}}              \\
    \hline
    Nem igényel fordítást, gyorsan lehet prototípizálni vele & Semmi reális tapasztalatom nincs a nyelvvel             \\
    Páratlan listafeldolgozási képességekkel rendelkezik & Idegen, nehezen átlátható szintaxissal rendelkezik      \\    
    Kiforrott standard könyvtárral rendelkezik & Nem internetes futtatásra kitalált nyelv \\               
    A kód maga egyben adat is & Nem szeretném használni                                 \\
    \hline
  \end{tabularx}
\end{center}

\subsection{WASM-ra forduló nyelv használata}

Második opció, hogy egy olyan nyelvet használunk, mely képes WASM formátumba fordulni. Ez egy pár évvel ezelőtt bevezett nyelv, mely a JavaScripttől eltérően egy verem-alapú, bájtkóddal reprezentált programozási nyelv. Különlegessége, hogy több olyan programozási nyelv, mely korábban csak asztali környezetben volt használható lefordítható rá, így lehetőségünk nyílik ezek használatára webes környezetben is.

„Az Emscripten egy nyílt-forráskódú fordító WebAssembly-re. A segítségével C és C++ kódot vagy bármely más LLVM-et használó nyelvet WebAssembly-re fordíthatunk és az Web-en, Node.js-en, vagy más wasm futtatási környezetben futtathatjuk.”\cite{emscripten}

Bár ez a projektem szempontjából sokkal járhatóbb út, mint az első lehetőség, itt is felmerül, hogy a WASM és a JavaScriptes környezetek között oda és vissza kell konvertálnunk az adatokat. Például a WASM natívan nem támogatja a szöveges értékeket\cite{wasmstring}, így ezeket C-szerű szövegekként (vagyis számokat tartalmazó tömbökként) kellene kezelnünk. Mivel az implementációmban másodlagos a fordító sebessége és az egyik felmerült nyelvet se találtam kifejezetten alkalmasabbnak mint a JavaScript, így az ezzel a módszerrel nyert előnyök számomra nem ellensúlyozzák az extra lépéseket.

\subsubsection{C}

Természetesen nem hagyhatjuk ki az egyik legöregebb és mégis széles körűen használatos nyelvet.

A C pozitívumai közé sorolandó, hogy nagyon könnyen lehet más platformokra fordítani. Az Emscripten nevű fordítói csomag segítségével a C WASM formátumba is fordítható, ezáltal böngészőben is futni képes.

A nyelv pozitívumai közé sorolandó még, hogy nem túl „meglepő” (kevés szintaxissal és aránylag átlátható szabályokkal rendelkezik), kifejezetten gyors és kis állományokká fordul, és szinte páratlan szabadságot ad a fejlesztőnek a rendszer erőforrásainak felhasználásához.

Cserébe a több évtizedes standard könyvtár és a nyelv pár furcsasága miatt könnyen futhat a programozó furcsa hibákba, mint például a szövegeknél esetlegesen hiányzó null byteok esetén történő túlcsordulások, vagy a hibásan lefoglalt / korábban felszabadított memóriaterületekre való írás/olvasás esetén előforduló végzetes hibák.

Ezen kívül a teljesen manuális memóriakezelés bár nagyon hasznos tud lenni, de jelen problémához fölösleges extra terhet jelentene csupán. Ezen kívül a nyelv nem támogatja az osztályokat, helyette struct-ok átadogatásával oldjuk meg az egybefüggő objektumok megváltoztatását. Ez könnyen tud átláthatatlansághoz vezetni, melyet egy ilyen nem-triviális projektnél nem szívesen vállalnék.

Végül a nyelv nem támogatja az objektum-orientált programozási paradigmát (\textit{Object-Oriented} \textit{Programming}, OOP), helyette az egyes függvények paraméterként fogadják az adatszerkezeteket, melyeken dolgoznak. Bár ennek segítségével lehetséges utánozni az osztály-orientált programozási stílust, én mégis szívesebben választanék olyan nyelvet, mely ezt beépítve támogatja.

Bár a nyelv az egyik személyes kedvencem, számomra nem megfelelő a feladathoz. A nyelv értékelésének összefoglalója az \ref{cnyelv} táblázatban látható.

\begin{center}
  \captionof{table}{A C nyelv értékelése.\label{cnyelv}}
  \begin{tabularx}{\textwidth}{X X}
    \hline
    \multicolumn{1}{c}{\bfseries{Pozitívumok}} & \multicolumn{1}{c}{\bfseries{Negatívumok}}                                  \\
    \hline
    Könnyen fordítható WASM-be                 & Manuális memóriakezelés                                                     \\
    Jól felszerelt eszköztár                   & Nem támogatja az OOP-t \\
    Személyes ismeretség                       & Kényelmi funkciók hiánya (pl.: regex) \\
    Más nyelveket is ebben írtak (pl.: Python) & Nincs könnyű mód a hibakezelésre \\
    \hline
  \end{tabularx}
\end{center}

\subsubsection{C++}

A C++ kijavítja a C főbb hibáit a RAII-vel (Resource Aquisition Is Initialization\cite{raii}, „az erőforrás lefoglalása egyben inicializáció is,” magyarul a különböző adattagok létrehozásakor a memória automatikusan lefoglalódik, megszűnésükkor pedig felszabadul) és egy sokkal kevésbé meglepő standard könyvtárral, viszont cserébe saját negatívumokkal is rendelkezik.

Bár az Emscripten képes WASM formátumba fordítani a nyelvet, a hibakezelése problematikus. Alapesetben a generált kód végzetes hibával lép ki bármilyen hiba esetén, beleértve az amúgy elkapható exception-öket. Ugyan egy kapcsoló segítségével engedélyezhetjük, hogy az utóbbi hibák újra elkaphatóak legyenek, ez súlyos lelassuláshoz vezet a programban.\cite{slowdown}

Ezen kívül a szövegkezelése a lentebb tárgyalt nyelvekhez képest igen nehézkes. Bár a C++ rendelkezik regex könyvtárakkal, de ezekkel kapcsolatban semmi ismeretségem nincs. A C++ hibakezelési képességei ellenére nem egy memóriabiztonságos nyelv, így hibás címzés vagy egy változó kétszeri felszabadítása nem definiált viselkedést okoz\cite{cppundefined}, mely könnyen vezethet segfaulthoz. A nyelv nem rendelkezik hivatalos csomagkezelővel sem, így a könyvtárak beimportálása nem feltétlen egyszerű és nem garantált, hogy ezek valóban át is fordulnának WASM-ra.

Mivel a nyelv használhatósága a feladathoz ennyire kétséges, így nem felel meg számomra. A nyelv értékelésének összefoglalója az \ref{cppnyelv}-es táblázatban látható.

\begin{center}
  \captionof{table}{A C++ nyelv értékelése.\label{cppnyelv}}
  \begin{tabularx}{\textwidth}{X X}
    \hline
    \multicolumn{1}{c}{\bfseries{Pozitívumok}}         & \multicolumn{1}{c}{\bfseries{Negatívumok}}                                             \\
    \hline
    Van OOP                                            & Van hibakezelés, de segfaultok is \\
    RAII (memóriakezelést leegyszerűsíti)              & A szövegkezelés nehézkes\\
    Ésszerű, kiforrott standard könyvtár               & A WASM-be való fordítás lassú, nehézkes                      \\
    Személyes tapasztalat (bár nem annyi mint a C-vel) & Nem minden külső könyvtár alkalmas a WASM-ba való fordításra                           \\
    \hline
  \end{tabularx}
\end{center}

\subsubsection{Rust}

\say{\textit{A Rust programozási nyelv segít, hogy gyorsabb és megbízhatóbb szoftvert írjunk. A magas-szintű ergonómia és az alacsony-szintű irányítás gyakran összeegyeztethetetlen a programozási nyelvek dizájnjában; a Rust ezt az állítást kérdőjelezi meg.}}\cite{rust}

A Rust egy relatíve új programozási nyelv, mely céljának a teljes memória-biztonságot és a gyakori hibák elkerülését tűzte ki, emellett natív fordításra is képes. A statikus analízise erősebb az összes fentebb felsorolt nyelvnél, a sebessége pedig a C/C++-hoz hasonlatos. Ezen kívül remek könyvtárakkal rendelkezik, melyek például a regexelést nagyon egyszerűvé teszik. A nyelv natívan fordul WebAssembly-re így ez se okoz problémát.

Cserébe a nyelv írása nagyon nehézkes, a fordító ott ahol tud felhívja a figyelmét a programozónak az esetleges hibákra vagy kifelejtett ellenőrzésekre. Ez természetesen a program minőségére nézve abszolút pozitív, ám cserébe nagyon nehézkessé teszi a prototípusok létrehozását.

Mivel a nyelv használata ilyen nehézkes és a prototípizálás lassú, így nem szeretném ezt a nyelvet választani. A nyelv értékelésének összefoglalója az \ref{rustnyelv}-os táblázatban látható.

\comptable{A Rust nyelv értékelése}{rustnyelv}{
  Gazdag standard könyvtár & Nehézkes szintaxissal rendelkezik \\
  Segfault átlagos kódban lehetetlen & Nincs vele elég tapasztalatom \\
  Remek könyvtárak, csomagkezelővel & Fordítás kicsit lassú \\
  Jó hibakezeléssel rendelkezik \\
  Natív fordulás WASM formátumba \\ 
}

\subsection{JavaScript és arra forduló nyelvek}

Végül lehetőségünk van még az egész programot JavaScriptben vagy egy arra forduló nyelvben írjuk meg. Ekkor nincs szükség semmiféle bonyolult adatátadási kódra, hisz az adatok a feldolgozás kezdetétől végééig natív JavaScriptes formátumban kerülnek eltárolásra. Végül emelett a módszer mellett döntöttem.

\subsubsection{JavaScript}

A JavaScript böngészőkben futó, általános célú nyelv. Az évtizedek során kinőtte egyszerű interaktivitást nyujtó funkcionalitását és mára egy kifejlett, dinamikus gyenge típusosságal rendelkező programozási nyelv.

Előnyei közé tartozik, hogy a nyelv automatikus memóriakezeléssel, dinamikus hosszúságú tömbökkel, és mutatók helyett referenciakezeléssel rendelkezik, így az egyes értékek szabadon egymásba ágyazhatóak. Emelett, mivel a böngészők natívan támogatják, így használata nem igényel fordítóprogramot.

Hátránya viszont, hogy mivel gyengén típusos nyelv, így a progamozónak saját magának kell megbizonyosodnia afelől, hogy az egyes függvények és műveletek megfelelő típusú értékeken kerülnek elvégzésre. Ez könnyen vezethet óvatlanságból hibákhoz, főleg egy ilyen volumenű programban, így végül a TypeScript mellett döntöttem. A nyelv bemutatása a \ref{jsnyelv} táblában látható.

\comptable{A JavaScript nyelv értékelése}{jsnyelv}{
  Natívan fut a böngészőkben & Gyengén típusos \\
  Dinamikus memóriakezelés & Nagy kódbázis esetén átláthatatlan \\
  Nem igényel fordítást \\
  Homokozóban fut, biztonságos \\
  Szabadon egymásba ágyazható adatszerkezetekkel rendelkezik \\
}

\subsubsection{TypeScript}

A TypeScript a JavaScript-et kiegészítő nyelv. Bármely JavaScriptben írt kód érvényes TypeScript kódnak felel meg, fordítva viszont ez nem igaz. Az eredeti nyelv gyenge típusosságát igyekszik kiküszöbölni azzal, hogy a kód egy típusellenörző-fordítón kerül átalakításra először, mely képes kiszűrni a típushibák nagyját.

A JavaScript összes előnyével rendelkezik, azon felül még az óvatlanságból eredő hibák nagyját is megelőzi és egyéb a kód rendezettségét növelő funkcionalitással is rendelkezik (enumok, interfészek), mely az eredeti nyelv kissé kezdetleges osztályait kiegészíti úgy, hogy valódi OOP elvű kódot lehessen írni benne.

Hátránya, hogy egy extra fordítási lépést igényel és hiába a típusellenőrzés, vannak szituációk, amik esetében a típusellenörző képtelen önmagától ítéletet hozni.

Végül emellett a nyelv mellett döntöttem és az egész projekt, beleértve a fordítót és az azt meghajtó felhasználói felületet, így TypeScript nyelven írtam. A nyelv bemutatása a \ref{tsnyelv} táblában látható.

\comptable{A TypeScript nyelv értékelése}{tsnyelv}{
  A JavaScript összes pozitívuma & Fordítani szükséges \\
  Aránylag jó típusossággal és típus-inferenciával rendelkezik & Azonban vannak esetek, amikor a típusrendszer nem képes önállóan dolgozni \\
  Támogatja az osztályokat és interfészeket & A típusosság fordítás után elveszik \\
}

\subsubsection{ReScript}

A ReScript az OCaml nyelv szintaxisát kölcsönző programozási nyelv, mely JavaScriptre fordul. A TypeScripttel ellentétben nincs olyan szituáció, hogy a kód típusossága ne lehetne kiszámítható benne.

Hisz a dolgozatra való készülésben sokat segített a \ref{sec:simpl} alfejezetben tárgyalt SimPL nyelv, mely szintén OCaml nyelvben íródott, így fölmerült bennem, hogy ideális lenne a könyből tanult módszereket egy olyan nyelvben kamatoztatni, mely végül szintén JavaScriptre fordul, így eleget téve annak a kívánságnak, hogy ne kelljen két külön futtatási környezet között konvertálnunk adatokat.

Sajnos azonban a nyelvvel való kísérletezés során arra jutottam, hogy nagyon kényelmetlen számomra a használata és azon parser algoritmus, melyet fel szerettem volna használni a nyelv egy limitációja miatt nem is működne. Ezt kiküszöbölni csupán azzal lehetett volna, ha JavaScript nyelven írt függvényeket hívünk meg, majd az azok által nyújtott értékekkel dolgozunk tovább. Azonban ezzel a módszerrel a nyelv fő erősségét vesztettem volna el, így sajnos látványos előnyei ellenére el kellett vetnem a használatát. A nyelv bemutatása a \ref{rsnyelv} táblában látható.

\comptable{A ReScript nyelv értékelése}{rsnyelv}{
  Sok programozási minta tömörebb, mint más nyelvekben & A használni kívánt algoritmust nem támogatja \\
  Nincs null érték, se \texttt{undefined} & Fordítóprogramot igényel \\
  Erősen és statikusan típusos & A fejlesztése nem aktív \\
  & Egyes funkciókhoz szükséges JavaScript kódot hívnunk, melyek helyességéről nem tudunk meggyőződni \\
}